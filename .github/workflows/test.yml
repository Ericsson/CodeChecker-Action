name: 'Action test'

on:
  pull_request:
    paths-ignore:
      - '**.md'
  push:
    branches:
      - master
      - 'releases/*'
    paths-ignore:
      - '**.md'

jobs:
  # Fetch tests do not produce results, but test the functionality of the
  # "grab LLVM" and "grab and build CodeChecker" features.
  fetch_ubuntu-2004_latest-llvm:
    name: "Fetch: Ubuntu Linux 20.04 (latest LLVM)"
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v2
      - uses: ./
        with:
          version: "master"
          llvm-version: "latest"
          logfile: "test/empty/compile_commands.json"
  fetch_ubuntu-1804_12-llvm:
    name: "Fetch: Ubuntu Linux 18.04 (LLVM 12.y)"
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2
      - uses: ./
        with:
          version: "master"
          llvm-version: 12
          logfile: "test/empty/compile_commands.json"

  # Test simple build and analysis configuration.
  simple-analysis-tests:
    strategy:
      fail-fast: false
      matrix:
        logfile: ['', 'test/simple/compile_commands.json']
        build-command: ['', 'cd test/simple; g++ -c main.cpp -o main.o']
        analyze-output: ['', 'my-output-dir']

    name: "Simple analysis: ${{ matrix.logfile && 'logfile' || 'no logfile' }}, ${{ matrix.build-command && 'build-command' || 'no build-command' }}, ${{ matrix.analyze-output && 'analyze-output' || 'no analyze-output'}}"
    runs-on: ubuntu-20.04


    steps:
      - uses: actions/checkout@v2
      - run: test/fix_compile_json_paths.sh
      - uses: ./
        id: codechecker
        # Allow continuing the build, we check "expected failure" for misconfiguration.
        continue-on-error: ${{ (matrix.logfile != '') == (matrix.build-command != '') }}
        with:
          logfile: ${{ matrix.logfile }}
          build-command: ${{ matrix.build-command }}
          analyze-output: ${{ matrix.analyze-output }}
      - name: "Check and reject job if previous test should have failed, but did not"
        if: ${{ steps.codechecker.continue-on-error && steps.codechecker.outcome != 'failure' }}
        run: |
          echo "::error title=Step with expected failure passed::"
          exit 1

  analyze-cfg:
    name: "Analyze: Custom configuration"
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v2
      - run: test/fix_compile_json_paths.sh
      - uses: ./
        with:
          config: 'test/codechecker.verbose.json'
          logfile: 'test/simple/compile_commands.json'
  analyze-ctu:
    name: "Analyze: CTU shortcut"
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v2
      - run: test/fix_compile_json_paths.sh
      - uses: ./
        id: codechecker
        with:
          logfile: 'test/ctu/compile_commands.json'
          ctu: true
      - name: "Reject test if previous step did not produce CTU finding"
        run: cat ${{ steps.codechecker.outputs.result-log }} | grep "Dereference of null pointer"

  fail-on-error:
    name: "Parse: Fail the build on error"
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v2
      - run: test/fix_compile_json_paths.sh
      - uses: ./
        id: codechecker
        continue-on-error: true
        with:
          logfile: 'test/simple/compile_commands.json'
          fail-build-if-reports: true
      - name: "Reject test if previous step did not fail"
        if: ${{ steps.codechecker.outcome != 'failure' }}
        run: |
          echo "::error title=fail-on-error test passed::Expected the 'parse' step to breka the build."
          exit 1

  parse-html:
    name: "Parse: Generate and upload report HTML artefact"
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v2
      - run: test/fix_compile_json_paths.sh
      - uses: ./
        id: codechecker
        with:
          logfile: 'test/simple/compile_commands.json'
      - uses: actions/upload-artifact@v2
        with:
          name: "Parse HTML test results"
          path: ${{ steps.codechecker.outputs.result-html-dir }}
